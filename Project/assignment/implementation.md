3 System Overview
3.1 High-Level Encoding and Decoding Pipeline
The system operates in two main stages: encoding and decoding.
• Encoding Pipeline:
1. Read and preprocess input image frames.
2. Divide each frame into fixed-size macroblocks (e.g., 8 × 8).
3. For I-frames, apply DCT, quantization, zigzag scan, and run-length encoding
to each macroblock.
4. For P-frames, compute the residual with respect to the previous frame, and
apply the same compression steps to the residual blocks.
5. Serialize and write the compressed macroblocks into a binary bytestream.
• Decoding Pipeline:
1. Read and parse the bytestream.
2. For I-frames, decode each macroblock directly via inverse RLE, inverse zigzag
scan, dequantization, and inverse DCT.
3. For P-frames, reconstruct the residual macroblocks and add them to the previous reconstructed frame.
4. Reassemble macroblocks into full frame images.
3.2 Role of Macroblocks
Macroblocks play a central role in both spatial and temporal compression:
• Spatial Compression: Each macroblock is processed independently using the
Discrete Cosine Transform and quantization to reduce spatial redundancy within a
frame.
• Temporal Compression: In P-frames, macroblocks are used to compute and store
residuals relative to corresponding macroblocks from previous frames, capturing
temporal changes efficiently.
This block-based approach allows for localized processing and is aligned with how
real-world codecs like H.264/AVC function, albeit in a simplified form.
3.3 GOP Structure Used in the Project
The implemented encoder uses a fixed-length GOP (Group of Pictures) pattern consisting
of one I-frame followed by multiple P-frames. For example:
GOP size 5: I P P P P
GOP size 15: I P P P P P P P P P P P P P P


4 Implementation Details
You are provided two helper functions frame to mb.m and mb to frame.m which are
inverse of each other. You do not have to use them, but they provide a good starting
point.
• The function frame to mb.m accepts a single parameter frame. frame is expected
to have the same shape as the result of the function imread.
• The height and the width dimensions of the image is expected to be divisible by 8.
• If the input image is in dimensions (360, 480, 3), the function frame to mb.m returns
a cell array data structure mb cells of shape (45, 60) where mb cells(i, j) is
the (8, 8, 3) macroblock located at row i and column j.
Implement the encoding and decoding pipeline described in the previous section. Provide two files decompress.m, compress.m for decoding and encoding respectively. Note
that all your functions do not need to be in these files. You can create as many scripts
as you want.
• compress.m script should encode the video located at ./video data/ folder we have
provided. Resulting bytestream should be saved in file result.bin. GOP size
should be declarable as a constant at the beginning of the script.
• decompress.m script should decode the video in file result.bin and save the results
as .jpg files in the folder ./decompressed/ using the same naming convention as
the input images. GOP size should be declarable as a constant at the beginning of
the script.
You will observe that the total size of the .jpg files is much lower than our compressed
binary. However, our simplistic approach cannot beat well-established JPEG compression. When we consider the actual video data, with 120 frames and 24 bit for each pixel.
The number 480 × 360 × 24 × 120 is around 62 megabytes. Meaning that the actual data
we are compressing is 62 megabytes.
Important notes:
• MATLAB imports images as uint8 by default. We strongly suggest working in
type double. You can compute everything in double and use uint8 at inital and
final steps.
• The use of large language models in an educational manner is allowed. You are expected to be able to explain your code if asked. We strongly advise against directly
using code generated by LLMs as this might flag you in our cheating controls.
• In our testing, the video data was compressed into a binary of size 7.8 megabytes
using a GOP size of 30. There might be some variance depending on your implementations. However, if you are seeing binaries larger than 30 megabytes, this
should be a cause of concern.